<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ponzi Scheme Visualizer: Shrinking Operator</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffaa;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 255, 170, 0.5);
        }

        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; text-transform: uppercase; }
        p { font-size: 0.9rem; color: #aaa; max-width: 300px; line-height: 1.4; }

        .stat-box {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 20, 10, 0.8);
            border: 1px solid #00ffaa;
            border-radius: 4px;
            display: inline-block;
        }

        #rug-pull-btn {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff0044;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(255, 0, 68, 0.6);
            transition: all 0.2s;
            pointer-events: auto;
            z-index: 10;
        }

        #rug-pull-btn:hover {
            background: #ff3366;
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 0 40px rgba(255, 0, 68, 1);
        }

        #rug-pull-btn:active {
            transform: translateX(-50%) scale(0.95);
        }

        .legend {
            margin-top: 10px;
            font-size: 0.8rem;
        }
        .dot { height: 10px; width: 10px; display: inline-block; border-radius: 50%; margin-right: 5px; }
        .dot-gold { background: #FFD700; box-shadow: 0 0 5px #FFD700; }
        .dot-green { background: #00ffaa; box-shadow: 0 0 5px #00ffaa; }
        .dot-purple { background: #aa00ff; box-shadow: 0 0 5px #aa00ff; }
        .dot-flow-up { background: #ffffff; box-shadow: 0 0 5px #ffffff; }
        .dot-flow-down { background: #ffaa00; box-shadow: 0 0 5px #ffaa00; }

        #game-over {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 3rem;
            color: #ff0044;
            font-weight: bold;
            display: none;
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
            text-align: center;
            z-index: 5;
            pointer-events: none;
            width: 100%;
        }
        #stolen-amount {
            font-size: 2rem;
            color: #FFD700;
            margin-bottom: 10px;
        }
        #restart-hint {
            font-size: 1.2rem;
            color: white;
            margin-top: 20px;
            opacity: 0.8;
            cursor: pointer;
            text-decoration: underline;
            pointer-events: auto;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            display: inline-block;
        }
        
        /* Histogram Labels */
        .histo-label {
            position: absolute;
            color: white;
            font-size: 0.8rem;
            font-weight: bold;
            text-align: center;
            display: none; /* Hidden until rug pull */
            bottom: 20%;
            width: 120px;
            transform: translateX(-50%);
            text-shadow: 0 0 5px #000;
        }
        #histo-1 { left: 20%; color: #ff0000; } /* Total Loss */
        #histo-2 { left: 40%; color: #ff4400; } /* Major Loss */
        #histo-3 { left: 60%; color: #ffff00; } /* Minor Loss */
        #histo-4 { left: 80%; color: #00ff00; } /* Profit */

    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Ponzi Scheme Anatomy</h1>
        <p>The Operator shrinks when paying out large "returns".</p>
        
        <div class="stat-box">
            <div><strong>Total Investors:</strong> <span id="investor-count">1</span></div>
            <div><strong>Operator Pot:</strong> $<span id="scheme-value">0</span></div>
        </div>

        <div class="legend">
            <div><span class="dot dot-gold"></span>Operator (Center)</div>
            <div><span class="dot dot-green"></span>New Investor</div>
            <div><span class="dot dot-purple"></span>Old Investor</div>
            <div><span class="dot dot-flow-up"></span>Large Deposit</div>
            <div><span class="dot dot-flow-down"></span>Big Withdrawal</div>
        </div>
    </div>

    <!-- Histogram Labels (Visible after collapse) -->
    <div id="histo-1" class="histo-label">TOTAL LOSS<br>100% Lost</div>
    <div id="histo-2" class="histo-label">MAJOR LOSS<br>>50% Lost</div>
    <div id="histo-3" class="histo-label">MINOR LOSS<br><50% Lost</div>
    <div id="histo-4" class="histo-label">PROFITers<br>(Early Birds)</div>

    <button id="rug-pull-btn">INITIATE RUG PULL</button>
    
    <div id="game-over">
        SCHEME COLLAPSED
        <div id="stolen-amount"></div>
        <div style="font-size: 1rem; color: #fff; margin-bottom: 10px;">Labels show: Invested / Withdrawn</div>
        <div id="restart-hint">Click to Restart</div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- Configuration ---
        const CONFIG = {
            addInvestorInterval: 1000, 
            cashFlowSpeed: 0.05,        
            transactionInterval: 400,   
            withdrawalChance: 0.1,    // Increased to 10% to ensure we see shrinking
            agingSpeed: 0.0001,        
            maxInvestors: 200,
            baseOperatorSize: 2.5
        };

        // --- Global Variables ---
        let scene, camera, renderer;
        let investors = []; 
        let connections = []; 
        let cashParticles = []; 
        let isCollapsed = false;
        let lastAdd = 0; 
        let lastTransaction = 0;
        
        // --- Classes ---

        class InvestorNode {
            constructor(id, parent, position, isRoot = false) {
                this.id = id;
                this.parent = parent; 
                this.children = []; 
                this.position = position.clone();
                this.targetPos = null; // For histogram
                this.isRoot = isRoot;
                this.creationTime = Date.now();
                
                // Financials
                this.invested = isRoot ? 0 : 5000; // Higher investment amount
                this.withdrawn = 0;

                // Physics
                this.velocity = new THREE.Vector3(0, 0, 0);
                
                // Visuals
                const geometry = new THREE.IcosahedronGeometry(isRoot ? CONFIG.baseOperatorSize : 0.8, 1);
                this.baseColor = new THREE.Color(isRoot ? 0xFFD700 : 0x00ffaa);
                this.targetColor = new THREE.Color(0xaa00ff); 
                
                const material = new THREE.MeshPhongMaterial({
                    color: this.baseColor,
                    emissive: isRoot ? 0xaa6600 : 0x002211,
                    shininess: 100,
                    flatShading: true
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                scene.add(this.mesh);

                this.hoverOffset = Math.random() * 100;
            }

            update(time) {
                if (!isCollapsed) {
                    // 1. Hover Animation
                    const hoverSpeed = this.isRoot ? 1 : 2;
                    this.mesh.position.y = this.position.y + Math.sin(time * hoverSpeed + this.hoverOffset) * 0.1;
                    
                    // Root rotates slowly
                    if(this.isRoot) {
                        this.mesh.rotation.y += 0.005;
                        this.mesh.rotation.z += 0.002;
                    } else {
                        this.mesh.rotation.y += 0.01;
                    }

                    // 2. Color Aging
                    if (!this.isRoot) {
                        const age = Date.now() - this.creationTime;
                        const ageFactor = Math.min(age / 45000, 1); 
                        this.mesh.material.color.lerpColors(this.baseColor, this.targetColor, ageFactor);
                        
                        const r = 0;
                        const g = 0.2 * (1 - ageFactor);
                        const b = 0.4 * ageFactor;
                        this.mesh.material.emissive.setRGB(r, g, b);
                    }
                } else {
                    // --- COLLAPSED STATE (Histogram Physics) ---
                    if (this.targetPos) {
                        const force = this.targetPos.clone().sub(this.mesh.position).multiplyScalar(0.05);
                        this.velocity.add(force);
                        this.velocity.multiplyScalar(0.9); 
                        this.mesh.position.add(this.velocity);
                        this.mesh.rotation.x += 0.05;
                    }
                }
            }

            receivePayout() {
                this.mesh.material.emissive.setHex(0xffffff);
                setTimeout(() => {
                    if(!isCollapsed) {
                        const age = Date.now() - this.creationTime;
                        const ageFactor = Math.min(age / 45000, 1);
                        this.mesh.material.emissive.setRGB(0, 0.2 * (1 - ageFactor), 0.4 * ageFactor);
                    }
                }, 300);
                
                // HUGE PAYOUT to ensure Operator shrinks
                // Random between $5,000 and $25,000
                const amount = 5000 + Math.floor(Math.random() * 20000);
                this.withdrawn += amount; 
            }

            die() {
                scene.remove(this.mesh);
                if (this.mesh.geometry) this.mesh.geometry.dispose();
                if (this.mesh.material) this.mesh.material.dispose();
                // If there are children (labels), remove them
                while(this.mesh.children.length > 0){ 
                    this.mesh.remove(this.mesh.children[0]); 
                }
            }
        }

        class CashParticle {
            constructor(startNode, endNode, type = 'investment') {
                this.startPos = startNode.mesh.position.clone();
                this.endPos = endNode.mesh.position.clone();
                this.progress = 0;
                this.active = true;
                this.type = type; 

                const color = type === 'investment' ? 0xffffff : 0xffaa00;
                const geometry = new THREE.SphereGeometry(0.4, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: color });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.startPos);
                scene.add(this.mesh);
            }

            update() {
                if (!this.active) return;

                this.progress += CONFIG.cashFlowSpeed;
                this.mesh.position.lerpVectors(this.startPos, this.endPos, this.progress);

                const scale = 1 + Math.sin(this.progress * Math.PI) * 0.5;
                this.mesh.scale.set(scale, scale, scale);

                if (this.progress >= 1) {
                    this.active = false;
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                    
                    if (!isCollapsed) updateUI();
                }
            }
        }

        // --- Helper Functions ---

        function makeTextSprite(message, color) {
            const fontface = "Arial";
            const fontsize = 24;
            const borderThickness = 2;
            
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Background
            context.fillStyle = "rgba(0,0,0,0.7)";
            context.fillRect(0,0,256,128);

            // Text
            context.font = "Bold " + fontsize + "px " + fontface;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Split message by newline
            const lines = message.split('\n');
            for(let i = 0; i < lines.length; i++) {
                context.fillText(lines[i], 128, 40 + (i * 30));
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(4, 2, 1);
            return sprite;
        }

        function calculateOperatorPot() {
             let pot = 0;
             investors.forEach(inv => {
                 if (!inv.isRoot) {
                     pot += (inv.invested - inv.withdrawn);
                 }
             });
             return pot;
        }

        function updateOperatorSize() {
            if(!investors[0] || isCollapsed) return;
            const pot = calculateOperatorPot();
            
            // Growth formula: Base size + (Pot / 50,000)
            let growth = pot / 50000; 
            if (growth > 12) growth = 12; // Cap max scale
            if (growth < -0.5) growth = -0.5; // Cap min scale (don't disappear completely)
            
            const targetScale = 1 + growth;
            // Smoothly interpolate
            const currentScale = investors[0].mesh.scale.x;
            const newScale = currentScale + (targetScale - currentScale) * 0.05;
            
            investors[0].mesh.scale.setScalar(newScale);
        }

        // --- Init ---

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 60); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            scene.add(new THREE.AmbientLight(0x404040));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);
            const pointLight = new THREE.PointLight(0x00ffaa, 1, 50); 
            pointLight.position.set(0,0,0);
            scene.add(pointLight);

            // Floor
            const gridHelper = new THREE.GridHelper(100, 50, 0x333333, 0x111111);
            gridHelper.position.y = -20; 
            scene.add(gridHelper);

            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('rug-pull-btn').addEventListener('click', triggerRugPull);
            document.getElementById('restart-hint').addEventListener('click', resetSimulation);
            
            setupCameraControls();
            resetSimulation();
            animate();
        }

        function setupCameraControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            const dom = document.getElementById('canvas-container');

            dom.addEventListener('mousedown', () => isDragging = true);
            window.addEventListener('mouseup', () => isDragging = false);
            dom.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                    };
                    
                    const rotSpeed = 0.005;
                    const x = camera.position.x;
                    const z = camera.position.z;
                    camera.position.x = x * Math.cos(deltaMove.x * rotSpeed) - z * Math.sin(deltaMove.x * rotSpeed);
                    camera.position.z = x * Math.sin(deltaMove.x * rotSpeed) + z * Math.cos(deltaMove.x * rotSpeed);
                    camera.lookAt(0, 0, 0); 
                }
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
        }

        function resetSimulation() {
            investors.forEach(inv => inv.die());
            connections.forEach(obj => {
                scene.remove(obj.mesh);
                obj.mesh.geometry.dispose();
                obj.mesh.material.dispose();
            });
            cashParticles.forEach(p => {
                scene.remove(p.mesh);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
            });

            investors = [];
            connections = [];
            cashParticles = [];
            isCollapsed = false;
            
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('rug-pull-btn').style.display = 'block';
            document.querySelectorAll('.histo-label').forEach(el => el.style.display = 'none');

            camera.position.set(0, 0, 60);
            camera.lookAt(0, 0, 0);

            // Create Root at Center (0,0,0)
            const root = new InvestorNode(0, null, new THREE.Vector3(0, 0, 0), true);
            investors.push(root);

            updateUI();
        }

        function addInvestor() {
            if (isCollapsed || investors.length >= CONFIG.maxInvestors) return;

            // SPHERICAL POSITIONING
            const radius = 12 + (Math.cbrt(investors.length) * 4); 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);

            const node = new InvestorNode(investors.length, investors[0], new THREE.Vector3(x, y, z));
            investors.push(node);
            investors[0].children.push(node);

            // Tube Connection
            const geometry = new THREE.BufferGeometry().setFromPoints([investors[0].position, node.position]);
            const material = new THREE.LineBasicMaterial({ color: 0x004422, transparent: true, opacity: 0.2 });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            connections.push({ mesh: line });

            updateUI();
        }

        function triggerCashFlow() {
            if (isCollapsed) return;

            if (Date.now() - lastTransaction < CONFIG.transactionInterval) return;
            lastTransaction = Date.now();

            // 1. Upward Flow (Investment)
            const idx = Math.floor(Math.random() * (investors.length - 1)) + 1;
            const inv = investors[idx];
            if (inv) {
                cashParticles.push(new CashParticle(inv, investors[0], 'investment'));
            }

            // 2. Downward Flow (Withdrawals)
            if (Math.random() < CONFIG.withdrawalChance && investors.length > 5) {
                const now = Date.now();
                const eligible = investors.filter(inv => !inv.isRoot && (now - inv.creationTime > 4000));
                
                if (eligible.length > 0) {
                    const luckyIdx = Math.floor(Math.random() * eligible.length);
                    const luckyInvestor = eligible[luckyIdx];
                    luckyInvestor.receivePayout();
                    cashParticles.push(new CashParticle(investors[0], luckyInvestor, 'withdrawal'));
                }
            }
        }

        function triggerRugPull() {
            if (isCollapsed) return;
            isCollapsed = true;

            const stolenAmount = calculateOperatorPot();
            document.getElementById('stolen-amount').innerHTML = `OPERATOR STOLE: <br>$${stolenAmount.toLocaleString()}`;

            const root = investors[0];
            scene.remove(root.mesh);
            connections.forEach(c => scene.remove(c.mesh));
            connections = [];

            const binX = [-15, -5, 5, 15]; 
            const binCounts = [0, 0, 0, 0]; 

            // Process investors for collapse
            for (let i = 1; i < investors.length; i++) {
                const inv = investors[i];
                const net = inv.invested - inv.withdrawn;
                const lossRatio = net / inv.invested; 
                
                let binIndex = 0; 
                if (lossRatio >= 1.0) binIndex = 0;      
                else if (lossRatio >= 0.5) binIndex = 1; 
                else if (lossRatio > 0) binIndex = 2;    
                else binIndex = 3;                       
                
                const x = binX[binIndex] + (Math.random() - 0.5) * 2; 
                const z = (Math.random() - 0.5) * 6; 
                const y = -20 + (binCounts[binIndex] * 1.6) + 0.8; 
                
                binCounts[binIndex]++;
                inv.targetPos = new THREE.Vector3(x, y, z);
                
                let textColor = "#ffffff";
                if(binIndex === 0) { inv.mesh.material.color.setHex(0xff0000); textColor="#ff0000"; }
                else if(binIndex === 1) { inv.mesh.material.color.setHex(0xff4400); textColor="#ff4400"; }
                else if(binIndex === 2) { inv.mesh.material.color.setHex(0xffff00); textColor="#ffff00"; }
                else { inv.mesh.material.color.setHex(0x00ff00); textColor="#00ff00"; }
                
                inv.mesh.material.emissive.setHex(0x000000);

                // --- ADD LABEL ---
                // Format: In: 5000 / Out: 2000
                const labelText = `In: $${inv.invested}\nOut: $${inv.withdrawn}`;
                const sprite = makeTextSprite(labelText, textColor);
                sprite.position.set(0, 1.5, 0); // Position above sphere
                inv.mesh.add(sprite);
            }

            document.getElementById('rug-pull-btn').style.display = 'none';
            document.getElementById('game-over').style.display = 'block';
            document.querySelectorAll('.histo-label').forEach(el => el.style.display = 'block');
        }

        function updateUI() {
            document.getElementById('investor-count').innerText = investors.length;
            document.getElementById('scheme-value').innerText = calculateOperatorPot().toLocaleString();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            if (!isCollapsed && Date.now() - lastAdd > CONFIG.addInvestorInterval) {
                addInvestor();
                lastAdd = Date.now();
                if (CONFIG.addInvestorInterval > 400) CONFIG.addInvestorInterval -= 2;
            }

            // Grow Operator Logic
            updateOperatorSize();
            triggerCashFlow();

            investors.forEach(inv => inv.update(time));

            for (let i = cashParticles.length - 1; i >= 0; i--) {
                cashParticles[i].update();
                if (!cashParticles[i].active) cashParticles.splice(i, 1);
            }

            renderer.render(scene, camera);
        }

        init();

    </script>
</body>
</html>