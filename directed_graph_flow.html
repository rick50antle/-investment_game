<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accounting Event Horizon Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc;
            pointer-events: auto;
            text-shadow: 0 0 10px #00ffcc;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border: 1px solid #00ffcc;
            border-radius: 8px;
        }
        /* Control buttons (Stop / Reset) */
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        .control-btn {
            background: rgba(0,0,0,0.6);
            color: #00ffcc;
            border: 1px solid rgba(0,255,204,0.25);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 700;
            backdrop-filter: blur(4px);
        }
        .control-btn:hover { background: #00ffcc; color: #001; }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; }
        .stat { font-size: 1rem; margin-bottom: 5px; }
        .legend { margin-top: 15px; font-size: 0.8rem; opacity: 0.8; }
        .legend-item { display: flex; align-items: center; margin-bottom: 3px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>Accounting Singularity</h1>
    <div class="stat" id="cash-display">Cash: $1000</div>
    <div class="stat" id="equity-display">Equity: $1000</div>
    <div class="stat" id="loan-display">Loan: $0</div>
   
    <div class="legend">
        <div class="legend-item"><div class="dot" style="background:cyan; box-shadow: 0 0 5px cyan;"></div>Stock Issuance (In)</div>
        <div class="legend-item"><div class="dot" style="background:orange; box-shadow: 0 0 5px orange;"></div>Borrowing (In)</div>
        <div class="legend-item"><div class="dot" style="background:white; box-shadow: 0 0 5px white;"></div>Dividend (Out)</div>
        <div class="legend-item"><div class="dot" style="background:red; box-shadow: 0 0 5px red;"></div>Loan Repayment (Out)</div>
    </div>
    <div id="flow-controls" style="margin-top:12px; font-size:0.9rem;">
        <div style="margin-bottom:6px;">Stock flow (USD / month): <input id="stock-usd-month" type="number" step="1000" min="0" style="width:120px; margin-left:8px;"> <span id="stock-usd-month-display"></span></div>
        <div style="margin-bottom:6px;">Borrow flow (USD / month): <input id="borrow-usd-month" type="number" step="1000" min="0" style="width:120px; margin-left:8px;"> <span id="borrow-usd-month-display"></span></div>
        <div style="margin-bottom:6px;">Dividend flow (USD / month): <input id="dividend-usd-month" type="number" step="1000" min="0" style="width:120px; margin-left:8px;"> <span id="dividend-usd-month-display"></span></div>
        <div style="margin-bottom:6px;">Repayment flow (USD / month): <input id="repay-usd-month" type="number" step="1000" min="0" style="width:120px; margin-left:8px;"> <span id="repay-usd-month-display"></span></div>
        <div style="margin-top:8px;">Spawn chance (per frame): <input id="spawn-rate-input" type="range" min="0" max="0.2" step="0.005" style="vertical-align:middle; width:160px; margin-left:8px;"> <span id="spawn-rate-display"></span></div>
    </div>
</div>

<div id="controls">
    <button id="stop-btn" class="control-btn">Stop</button>
    <button id="reset-btn" class="control-btn">Reset</button>
</div>

<div id="canvas-container"></div>

<!-- Import Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- Configuration ---
    const CONFIG = {
        particleCount: 0, // Managed dynamically
        spawnRate: 0.05, // Chance per frame to spawn inflow
        outflowRate: 0.01, // Chance per frame to spawn outflow
        colors: {
            cash: 0x00ff00,
            equity: 0x00ffff,
            loan: 0xff4400,
            stockParticle: 0x00ffff,
            loanParticle: 0xffaa00,
            dividendParticle: 0xffffff,
            repayParticle: 0xff0000,
            blackHole: 0x000000,
            accretion: 0x220033
        }
    };

    // Estimated FPS and seconds per month for mapping USD/month -> per-particle value
    const FPS_EST = 60;
    const SECS_PER_MONTH = 30 * 24 * 3600; // 30 days

    // USD/month targets for each flow type. These are editable by the user via the UI.
    // We'll initialize them so default behavior is close to the previous hard-coded amounts.
    CONFIG.usdPerMonth = {
        stock: 0,
        borrow: 0,
        dividend: 0,
        repay: 0
    };

    // Helper: compute per-particle USD value from a USD/month target.
    function perParticleValue(type) {
        // Determine per-frame spawn probability for this type
        let perFrameProb = 0;
        if (type === 'stock' || type === 'borrow') {
            // spawnRate selects an inflow, split roughly 50/50 between stock and borrow
            perFrameProb = CONFIG.spawnRate * 0.5;
        } else {
            // dividends/repay use outflowRate
            perFrameProb = CONFIG.outflowRate;
        }

        const particlesPerMonth = perFrameProb * FPS_EST * SECS_PER_MONTH;
        if (particlesPerMonth <= 0) {
            // fallback to small constant
            return (type === 'stock' || type === 'borrow') ? 50 : 25;
        }
        const usdMonth = CONFIG.usdPerMonth[type] || 0;
        const perParticle = usdMonth / particlesPerMonth;
        // avoid zero-valued particles
        return Math.max(1, perParticle);
    }

    // --- State ---
    const STATE = {
        cash: 1000,
        equity: 1000,
        loan: 0
    };

    // --- Scene Setup ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
   
    // Fog for depth
    scene.fog = new THREE.FogExp2(0x050505, 0.002);

    // We'll control the camera with a spherical controller so users can rotate/zoom
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    // Initial spherical coordinates (radius, theta, phi)
    const cameraSph = {
        radius: 60,
        theta: Math.atan2(40, 0),
        phi: Math.PI/2 - Math.atan2(30, 40)
    };
    function updateCameraFromSph() {
        const r = cameraSph.radius;
        const phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraSph.phi));
        const theta = cameraSph.theta;
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.cos(phi);
        const z = r * Math.sin(phi) * Math.sin(theta);
        camera.position.set(x, y, z);
        camera.lookAt(0, 0, 0);
    }
    // Set initial camera
    cameraSph.radius = 60; cameraSph.theta = 0; cameraSph.phi = 0.9;
    updateCameraFromSph();

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // --- Simple pointer controls (drag to rotate, wheel to zoom) ---
    (function setupPointerControls(){
        const el = renderer.domElement;
        let isDown = false;
        let start = {x:0,y:0, theta:0, phi:0};

        el.addEventListener('pointerdown', (e)=>{
            isDown = true;
            el.setPointerCapture(e.pointerId);
            start.x = e.clientX; start.y = e.clientY;
            start.theta = cameraSph.theta; start.phi = cameraSph.phi;
        });
        window.addEventListener('pointerup', (e)=>{ isDown = false; });
        el.addEventListener('pointermove', (e)=>{
            if(!isDown) return;
            const dx = e.clientX - start.x;
            const dy = e.clientY - start.y;
            // Sensitivity
            const sensX = 0.005; const sensY = 0.005;
            cameraSph.theta = start.theta - dx * sensX;
            cameraSph.phi = Math.max(0.1, Math.min(Math.PI - 0.1, start.phi - dy * sensY));
            updateCameraFromSph();
        });
        el.addEventListener('wheel', (e)=>{
            e.preventDefault();
            const delta = Math.sign(e.deltaY);
            cameraSph.radius = Math.max(10, Math.min(300, cameraSph.radius + delta * 4));
            updateCameraFromSph();
        }, {passive:false});
    })();

    // No navbar is inserted on this page — UI lives at the top of the canvas.

    // --- Textures & Materials ---
    // Helper to create a glowing dot texture programmatically
    function createGlowTexture(colorStr) {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        grad.addColorStop(0, 'white');
        grad.addColorStop(0.2, colorStr);
        grad.addColorStop(0.5, 'rgba(0,0,0,0.5)');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 64, 64);
        const tex = new THREE.CanvasTexture(canvas);
        return tex;
    }

    // Helper for Text Labels
    function createTextSprite(message, color) {
        const canvas = document.createElement('canvas');
        const size = 256;
        canvas.width = size;
        canvas.height = size / 2;
        const ctx = canvas.getContext('2d');
        ctx.font = 'Bold 40px Arial';
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 4;
        ctx.strokeText(message, size / 2, size / 4 + 10);
        ctx.fillText(message, size / 2, size / 4 + 10);
       
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(10, 5, 1);
        return sprite;
    }

    // --- Objects ---

    // 1. Starfield
    const starGeo = new THREE.BufferGeometry();
    const starCount = 2000;
    const starPos = new Float32Array(starCount * 3);
    for(let i=0; i<starCount*3; i++) {
        starPos[i] = (Math.random() - 0.5) * 300;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8});
    const starField = new THREE.Points(starGeo, starMat);
    scene.add(starField);

    // (Removed black hole and accretion disk visuals as requested.)

    // 3. Accounting Network Nodes
    // Layout: Cash (Top), Equity (Bottom Right), Loan (Bottom Left)
    const NODE_DIST = 12;
   
    const nodes = {
        cash: {
            mesh: null,
            pos: new THREE.Vector3(0, 0, -NODE_DIST),
            color: CONFIG.colors.cash,
            label: "CASH",
            baseSize: 2
        },
        equity: {
            mesh: null,
            pos: new THREE.Vector3(NODE_DIST * 0.866, 0, NODE_DIST * 0.5),
            color: CONFIG.colors.equity,
            label: "EQUITY",
            baseSize: 2
        },
        loan: {
            mesh: null,
            pos: new THREE.Vector3(-NODE_DIST * 0.866, 0, NODE_DIST * 0.5),
            color: CONFIG.colors.loan,
            label: "LOAN",
            baseSize: 1.5 // Start smaller
        }
    };

    Object.keys(nodes).forEach(key => {
        const n = nodes[key];
        // Sphere
        const geo = new THREE.SphereGeometry(1, 32, 32);
        const mat = new THREE.MeshStandardMaterial({
            color: n.color,
            emissive: n.color,
            emissiveIntensity: 0.5,
            roughness: 0.2,
            metalness: 0.8
        });
        n.mesh = new THREE.Mesh(geo, mat);
        n.mesh.position.copy(n.pos);
        scene.add(n.mesh);

        // Label
        const label = createTextSprite(n.label, '#ffffff');
        label.position.set(n.pos.x, n.pos.y + 3.5, n.pos.z);
        scene.add(label);
        n.labelSprite = label;
    });

    // 4. Edges
    const edges = {
        stock: { start: nodes.cash, end: nodes.equity, mesh: null, activeTimer: 0 },
        borrow: { start: nodes.cash, end: nodes.loan, mesh: null, activeTimer: 0 }
    };

    Object.keys(edges).forEach(key => {
        const e = edges[key];
        const points = [e.start.pos, e.end.pos];
        const path = new THREE.LineCurve3(e.start.pos, e.end.pos);
        const tubeGeo = new THREE.TubeGeometry(path, 1, 0.2, 8, false);
        const tubeMat = new THREE.MeshBasicMaterial({
            color: 0x555555,
            transparent: true,
            opacity: 0.3
        });
        e.mesh = new THREE.Mesh(tubeGeo, tubeMat);
        scene.add(e.mesh);
    });

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 1, 100);
    pointLight.position.set(0, 10, 0);
    scene.add(pointLight);

    // --- Particle System ---
    let particles = [];
   
    class Particle {
        constructor(type) {
            this.type = type; // 'stock', 'borrow', 'dividend', 'repay'
            this.active = true;
            this.t = 0; // Progress
           
            // Visuals
            let color, size;
            // Increased particle sizes for better visibility
            if(type === 'stock') { color = CONFIG.colors.stockParticle; size = 1.4; }
            else if(type === 'borrow') { color = CONFIG.colors.loanParticle; size = 1.8; }
            else if(type === 'dividend') { color = CONFIG.colors.dividendParticle; size = 1.2; }
            else if(type === 'repay') { color = CONFIG.colors.repayParticle; size = 1.2; }

            const mat = new THREE.SpriteMaterial({
                map: createGlowTexture(new THREE.Color(color).getStyle()),
                blending: THREE.AdditiveBlending
            });
            this.mesh = new THREE.Sprite(mat);
            this.mesh.scale.set(size, size, size);
           
            this.initMovement();
            scene.add(this.mesh);
        }

        initMovement() {
            // Inflow starts outside, goes to edges
            // Outflow starts at nodes, goes outside
            const radius = 40;
            const angle = Math.random() * Math.PI * 2;
            const height = (Math.random() - 0.5) * 10;

            if (this.type === 'stock' || this.type === 'borrow') {
                // Inflow
                this.startPos = new THREE.Vector3(Math.cos(angle)*radius, height, Math.sin(angle)*radius);
               
                // Target is the center of the relevant edge
                let nodeA, nodeB;
                if(this.type === 'stock') { nodeA = nodes.cash; nodeB = nodes.equity; }
                else { nodeA = nodes.cash; nodeB = nodes.loan; }
               
                this.targetPos = new THREE.Vector3().lerpVectors(nodeA.pos, nodeB.pos, 0.5);
                this.mesh.position.copy(this.startPos);
                this.speed = 0.005 + Math.random() * 0.005;
               
                // Spiral control
                this.spiralOffset = Math.random() * 10;
               
            } else {
                // Outflow
                this.startPos = nodes.cash.pos.clone(); // Money leaves cash
                // Target is outward
                this.targetPos = new THREE.Vector3(Math.cos(angle)*radius*2, height, Math.sin(angle)*radius*2);
                this.mesh.position.copy(this.startPos);
                this.speed = 0.01 + Math.random() * 0.01;
            }
        }

        update() {
            if (!this.active) return;
           
            this.t += this.speed;

            if (this.type === 'stock' || this.type === 'borrow') {
                // Spiral Movement Inwards
                // Lerp linear distance
                const currentPos = new THREE.Vector3().lerpVectors(this.startPos, this.targetPos, this.t);
               
                // Add spiral swirl (perpendicular to direction)
                if (this.t < 0.9) {
                    const offset = Math.sin(this.t * 5 + this.spiralOffset) * (1 - this.t) * 5;
                    currentPos.y += offset;
                }

                this.mesh.position.copy(currentPos);

                // Check collision/absorb
                if (this.t >= 1) {
                    this.absorb();
                }
            } else {
                // Linear Movement Outwards (Ejection)
                this.mesh.position.lerpVectors(this.startPos, this.targetPos, this.t);
                if (this.t >= 1) {
                    this.kill();
                }
            }
        }

        absorb() {
            // Update Accounting State
            if (this.type === 'stock') {
                    const amount = Math.round(perParticleValue('stock'));
                    STATE.cash += amount;
                    STATE.equity += amount;
                    pulseEdge('stock');
            } else if (this.type === 'borrow') {
                    const amount = Math.round(perParticleValue('borrow'));
                    STATE.cash += amount;
                    STATE.loan += amount;
                    pulseEdge('borrow');
            }
            updateUI();
            this.kill();
        }

        kill() {
            this.active = false;
            scene.remove(this.mesh);
        }
    }

    // --- Controls & Logic Helpers ---
    // Running flag — when false, the simulation pauses (no spawning/updates)
    let running = true;

    function pulseEdge(type) {
        edges[type].activeTimer = 1.0;
        edges[type].mesh.material.color.setHex(0xffffff);
        edges[type].mesh.material.opacity = 1;
    }

    function processOutflows() {
        // Dividend Logic: If cash is high, pay dividend
        if (STATE.cash > 500 && Math.random() < CONFIG.outflowRate) {
            const amount = Math.round(perParticleValue('dividend'));
            STATE.cash -= amount;
            STATE.equity -= amount;
            particles.push(new Particle('dividend'));
            updateUI();
        }

        // Repayment Logic: If Loan exists and cash is okay
        if (STATE.loan > 0 && STATE.cash > 200 && Math.random() < CONFIG.outflowRate) {
            const amount = Math.round(perParticleValue('repay'));
            STATE.cash -= amount;
            STATE.loan -= amount;
            particles.push(new Particle('repay'));
            updateUI();
        }
    }

    function updateNodeSizes() {
        // Smoothly interpolate size based on value
        // Base size + (Value / Divisor)
        const targetScaleCash = nodes.cash.baseSize + (STATE.cash / 500);
        const targetScaleEquity = nodes.equity.baseSize + (STATE.equity / 500);
        const targetScaleLoan = nodes.loan.baseSize + (STATE.loan / 500);

        nodes.cash.mesh.scale.lerp(new THREE.Vector3(targetScaleCash, targetScaleCash, targetScaleCash), 0.1);
        nodes.equity.mesh.scale.lerp(new THREE.Vector3(targetScaleEquity, targetScaleEquity, targetScaleEquity), 0.1);
        nodes.loan.mesh.scale.lerp(new THREE.Vector3(targetScaleLoan, targetScaleLoan, targetScaleLoan), 0.1);

        // Update Labels positions to follow scale
        nodes.cash.labelSprite.position.y = nodes.cash.pos.y + targetScaleCash + 1;
        nodes.equity.labelSprite.position.y = nodes.equity.pos.y + targetScaleEquity + 1;
        nodes.loan.labelSprite.position.y = nodes.loan.pos.y + targetScaleLoan + 1;
    }

    function updateEdgesVisuals() {
        Object.keys(edges).forEach(k => {
            const e = edges[k];
            if (e.activeTimer > 0) {
                e.activeTimer -= 0.05;
                // Fade back to grey
                e.mesh.material.color.lerp(new THREE.Color(0x555555), 0.1);
                e.mesh.material.opacity = 0.3 + (e.activeTimer * 0.7);
            }
        });
    }

    function updateUI() {
        document.getElementById('cash-display').innerText = `Cash: $${STATE.cash.toFixed(0)}`;
        document.getElementById('equity-display').innerText = `Equity: $${STATE.equity.toFixed(0)}`;
        document.getElementById('loan-display').innerText = `Loan: $${STATE.loan.toFixed(0)}`;
    }

    // --- Control Handlers ---
    function setRunning(val) {
        running = val;
        const btn = document.getElementById('stop-btn');
        btn.innerText = running ? 'Stop' : 'Start';
    }

    document.getElementById('stop-btn').addEventListener('click', () => {
        setRunning(!running);
    });

    document.getElementById('reset-btn').addEventListener('click', () => {
        // Clear particles
        particles.forEach(p => { try { p.kill(); } catch(e){} });
        particles = [];

        // Reset accounting state
        STATE.cash = 1000;
        STATE.equity = 1000;
        STATE.loan = 0;
        updateUI();

        // Reset node visuals to base sizes
        Object.keys(nodes).forEach(k => {
            const n = nodes[k];
            const s = n.baseSize;
            n.mesh.scale.set(s, s, s);
            n.labelSprite.position.y = n.pos.y + s + 1;
        });

        // Reset edges visuals
        Object.keys(edges).forEach(k => {
            edges[k].mesh.material.color.setHex(0x555555);
            edges[k].mesh.material.opacity = 0.3;
            edges[k].activeTimer = 0;
        });
    });

    // --- Main Loop ---

    function animate() {
        requestAnimationFrame(animate);

        if (running) {
            // 1. Spawn Inflow Particles
            if (Math.random() < CONFIG.spawnRate) {
                const type = Math.random() > 0.5 ? 'stock' : 'borrow';
                particles.push(new Particle(type));
            }

            // 2. Process Logic
            processOutflows();
            updateNodeSizes();
            updateEdgesVisuals();

            // 3. Update Particles
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.active); // Cleanup
        }

        // 4. Scene Animation (always animate minimal visuals)
        starField.rotation.y += 0.0005;
        // black hole and accretion visuals removed

        renderer.render(scene, camera);
    }

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    animate();

    // --- Wire up flow controls UI ---
    (function setupFlowControls(){
        // Initialize defaults so existing behavior is preserved roughly
        // Compute a default USD/month that results in ~50 USD per inflow particle
        try {
            const perTypeParticlesPerMonth = CONFIG.spawnRate * 0.5 * FPS_EST * SECS_PER_MONTH;
            const defaultPerParticle = 50;
            CONFIG.usdPerMonth.stock = Math.round(defaultPerParticle * perTypeParticlesPerMonth);
            CONFIG.usdPerMonth.borrow = Math.round(defaultPerParticle * perTypeParticlesPerMonth);

            const outflowParticlesPerMonth = CONFIG.outflowRate * FPS_EST * SECS_PER_MONTH;
            const defaultOutPerParticle = 25;
            CONFIG.usdPerMonth.dividend = Math.round(defaultOutPerParticle * outflowParticlesPerMonth);
            CONFIG.usdPerMonth.repay = Math.round(defaultOutPerParticle * outflowParticlesPerMonth);
        } catch(e) {
            // fallback
            CONFIG.usdPerMonth.stock = 200000;
            CONFIG.usdPerMonth.borrow = 200000;
            CONFIG.usdPerMonth.dividend = 50000;
            CONFIG.usdPerMonth.repay = 50000;
        }

        const stockInput = document.getElementById('stock-usd-month');
        const borrowInput = document.getElementById('borrow-usd-month');
        const divInput = document.getElementById('dividend-usd-month');
        const repayInput = document.getElementById('repay-usd-month');
        const spawnInput = document.getElementById('spawn-rate-input');

        function updateDisplays(){
            document.getElementById('stock-usd-month-display').innerText = `$${Number(CONFIG.usdPerMonth.stock).toLocaleString()}`;
            document.getElementById('borrow-usd-month-display').innerText = `$${Number(CONFIG.usdPerMonth.borrow).toLocaleString()}`;
            document.getElementById('dividend-usd-month-display').innerText = `$${Number(CONFIG.usdPerMonth.dividend).toLocaleString()}`;
            document.getElementById('repay-usd-month-display').innerText = `$${Number(CONFIG.usdPerMonth.repay).toLocaleString()}`;
            document.getElementById('spawn-rate-display').innerText = `${CONFIG.spawnRate.toFixed(3)}`;
        }

        stockInput.value = CONFIG.usdPerMonth.stock;
        borrowInput.value = CONFIG.usdPerMonth.borrow;
        divInput.value = CONFIG.usdPerMonth.dividend;
        repayInput.value = CONFIG.usdPerMonth.repay;
        spawnInput.value = CONFIG.spawnRate;
        updateDisplays();

        stockInput.addEventListener('change', (e)=>{ CONFIG.usdPerMonth.stock = Number(e.target.value || 0); updateDisplays(); });
        borrowInput.addEventListener('change', (e)=>{ CONFIG.usdPerMonth.borrow = Number(e.target.value || 0); updateDisplays(); });
        divInput.addEventListener('change', (e)=>{ CONFIG.usdPerMonth.dividend = Number(e.target.value || 0); updateDisplays(); });
        repayInput.addEventListener('change', (e)=>{ CONFIG.usdPerMonth.repay = Number(e.target.value || 0); updateDisplays(); });
        spawnInput.addEventListener('input', (e)=>{ CONFIG.spawnRate = Number(e.target.value); updateDisplays(); });

    })();

</script>
</body>
</html>